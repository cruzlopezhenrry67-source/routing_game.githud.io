<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Enrutamiento de Redes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 1000px;
            width: 100%;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
        }

        h3 {
            color: #764ba2;
            margin: 20px 0 15px 0;
            font-size: 1.5em;
        }

        .game-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .game-option {
            background: linear-gradient(45deg, #ff6b6b, #ffa500);
            color: white;
            padding: 25px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .game-screen {
            display: none;
            text-align: left;
        }

        .game-screen.active {
            display: block;
        }

        /* Estilos para la secci√≥n de teor√≠a */
        .theory-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: left;
        }

        .info-card {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 10px 10px 0;
        }

        .info-card ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .info-card li {
            margin: 5px 0;
            line-height: 1.6;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .table-container table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .table-container th,
        .table-container td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .table-container th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .table-container tr:hover {
            background: #f5f5f5;
        }

        /* Estilos para trivia */
        .question-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: left;
        }

        .question {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #333;
            font-weight: bold;
        }

        .options {
            display: grid;
            gap: 10px;
        }

        .option {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            border-color: #667eea;
            background: #f0f0ff;
        }

        .option.correct {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .option.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .score-board {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
        }

        .controls {
            margin: 20px 0;
            text-align: center;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn.secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
        }

        .algorithm-step {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 10px 10px 0;
        }

        /* Estilos para Sopa de Letras */
        .wordsearch-grid-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }

        .wordsearch-grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            gap: 2px;
            margin-bottom: 20px;
        }

        .ws-cell {
            width: 25px;
            height: 25px;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            border-radius: 4px;
        }

        .ws-cell:hover {
            background: #e3f2fd;
            transform: scale(1.1);
        }

        .ws-cell.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .ws-cell.found {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .wordsearch-words-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            min-width: 200px;
            max-width: 250px;
        }

        .ws-word-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9em;
        }

        .ws-word-item.found {
            background: #4CAF50;
            color: white;
            border-left-color: #45a049;
            text-decoration: line-through;
        }

        /* Estilos para matching game */
        .matching-item {
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .matching-item:hover {
            transform: scale(1.02);
        }

        .matching-item.selected {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .matching-item.matched {
            background: #d4edda !important;
            border-color: #28a745 !important;
            cursor: default;
        }

        .matching-columns {
            display: flex;
            gap: 20px;
            justify-content: space-between;
        }

        .matching-column {
            flex: 1;
            max-width: 45%;
        }

        .matching-column h4 {
            text-align: center;
            margin-bottom: 20px;
            color: #667eea;
            font-size: 1.3em;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üåê Juego de Enrutamiento de Redes</h1>
        
        <!-- Men√∫ Principal -->
        <div id="main-menu" class="game-screen active">
            <p style="font-size: 1.2em; color: #666; margin-bottom: 30px; text-align: center;">
                Aprende sobre enrutamiento est√°tico, din√°mico y algoritmos de vector distancia
            </p>
            
            <div class="game-menu">
                <button class="game-option" onclick="startGame('theory')">
                    üìö Teor√≠a de Enrutamiento
                </button>
                <button class="game-option" onclick="startGame('trivia')">
                    üß† Trivia de Enrutamiento
                </button>
                <button class="game-option" onclick="startGame('algorithm')">
                    üìä Vector Distancia
                </button>
                <button class="game-option" onclick="startGame('matching')">
                    üéØ Unir Conceptos
                </button>
                <button class="game-option" onclick="startGame('wordsearch')">
                    üîç Sopa de Letras
                </button>
            </div>
        </div>

        <!-- Secci√≥n de Teor√≠a -->
        <div id="theory-game" class="game-screen">
            <h2>üìö Teor√≠a: Enrutamiento Est√°tico y Din√°mico</h2>
            
            <div class="theory-section">
                <p style="font-size: 1.1em; line-height: 1.6; margin-bottom: 20px;">
                    El enrutamiento es el proceso mediante el cual un router selecciona el mejor camino para enviar paquetes hacia su destino. 
                    Existen dos enfoques principales: <strong>enrutamiento est√°tico</strong> y <strong>enrutamiento din√°mico</strong>.
                </p>

                <h3>Enrutamiento Est√°tico</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    Es aquel en el que las rutas son configuradas manualmente por el administrador de red. 
                    Se utilizan en redes peque√±as o con topolog√≠as muy estables.
                </p>
                <div class="info-card">
                    <ul>
                        <li><strong>Ventajas:</strong> Simplicidad, bajo consumo de recursos, mayor control del tr√°fico.</li>
                        <li><strong>Desventajas:</strong> No se adapta a cambios autom√°ticamente, dif√≠cil de administrar en redes grandes.</li>
                    </ul>
                </div>

                <h3>Enrutamiento Din√°mico</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    Utiliza protocolos de enrutamiento para que los routers intercambien informaci√≥n y ajusten autom√°ticamente sus tablas de enrutamiento. 
                    Ejemplos de protocolos son <strong>RIP, OSPF, EIGRP y BGP</strong>.
                </p>
                <div class="info-card">
                    <ul>
                        <li><strong>Ventajas:</strong> Adaptabilidad a cambios, escalabilidad en redes grandes.</li>
                        <li><strong>Desventajas:</strong> Mayor consumo de CPU, memoria y ancho de banda; m√°s complejo de configurar.</li>
                    </ul>
                </div>

                <h3>Comparaci√≥n</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Caracter√≠stica</th>
                                <th>Est√°tico</th>
                                <th>Din√°mico</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Configuraci√≥n</td>
                                <td>Manual</td>
                                <td>Autom√°tica (protocolos)</td>
                            </tr>
                            <tr>
                                <td>Escalabilidad</td>
                                <td>Baja</td>
                                <td>Alta</td>
                            </tr>
                            <tr>
                                <td>Adaptaci√≥n a fallos</td>
                                <td>Nula</td>
                                <td>Autom√°tica</td>
                            </tr>
                            <tr>
                                <td>Uso de recursos</td>
                                <td>Bajo</td>
                                <td>Moderado/Alto</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Protocolos de Enrutamiento Din√°mico</h3>
                <div class="info-card">
                    <ul>
                        <li><strong>RIP (Routing Information Protocol):</strong> Usa vector distancia, m√°ximo 15 saltos.</li>
                        <li><strong>OSPF (Open Shortest Path First):</strong> Protocolo de estado de enlace, usa algoritmo Dijkstra.</li>
                        <li><strong>EIGRP (Enhanced Interior Gateway Routing Protocol):</strong> Protocolo h√≠brido de Cisco.</li>
                        <li><strong>BGP (Border Gateway Protocol):</strong> Protocolo para enrutamiento entre sistemas aut√≥nomos.</li>
                    </ul>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn secondary" onclick="showMenu()">Men√∫ Principal</button>
            </div>
        </div>

        <!-- Trivia Game -->
        <div id="trivia-game" class="game-screen">
            <h2>üß† Trivia de Enrutamiento</h2>
            
            <div class="score-board">
                Puntuaci√≥n: <span id="score">0</span> / <span id="total-questions">0</span>
            </div>
            
            <div id="question-container" class="question-card">
                <!-- Las preguntas se cargar√°n aqu√≠ -->
            </div>
            
            <div class="controls">
                <button class="btn" onclick="nextQuestion()">Siguiente Pregunta</button>
                <button class="btn secondary" onclick="showMenu()">Men√∫ Principal</button>
            </div>
        </div>

        <!-- Algoritmo Vector Distancia -->
        <div id="algorithm-game" class="game-screen">
            <h2>üìä Algoritmo de Vector Distancia (Bellman-Ford)</h2>
            
            <div id="algorithm-steps">
                <!-- Los pasos se mostrar√°n aqu√≠ -->
            </div>
            
            <div class="routing-table">
                <h3>Evoluci√≥n de las Tablas de Enrutamiento</h3>
                <div id="distance-tables">
                    <!-- Tablas de distancia -->
                </div>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="runAlgorithmStep()">Siguiente Iteraci√≥n</button>
                <button class="btn" onclick="resetAlgorithm()">Reiniciar Algoritmo</button>
                <button class="btn secondary" onclick="showMenu()">Men√∫ Principal</button>
            </div>
        </div>

        <!-- Juego de Unir Conceptos -->
        <div id="matching-game" class="game-screen">
            <h2>üéØ Unir Conceptos de Enrutamiento</h2>
            
            <div class="score-board">
                Aciertos: <span id="matches">0</span> / <span id="total-matches">6</span>
            </div>
            
            <div id="matching-area" class="matching-columns">
                <!-- El juego de matching se cargar√° aqu√≠ -->
            </div>
            
            <div class="controls">
                <button class="btn" onclick="shuffleMatching()">Nueva Ronda</button>
                <button class="btn secondary" onclick="showMenu()">Men√∫ Principal</button>
            </div>
        </div>

        <!-- Sopa de Letras -->
        <div id="wordsearch-game" class="game-screen">
            <h2>üîç Sopa de Letras - T√©rminos de Enrutamiento</h2>
            
            <div class="score-board">
                Palabras encontradas: <span id="ws-foundCount">0</span> / <span id="ws-totalCount">10</span>
            </div>

            <div style="display: flex; gap: 30px; justify-content: center; align-items: flex-start; flex-wrap: wrap; margin: 20px 0;">
                <div class="wordsearch-grid-container">
                    <div class="wordsearch-grid" id="ws-letterGrid"></div>
                </div>

                <div class="wordsearch-words-panel">
                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 15px; color: #333; text-align: center;">Palabras a encontrar:</div>
                    <div id="ws-wordsList"></div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="newWordSearchGame()">üéÆ Nuevo Juego</button>
                <button class="btn" onclick="clearWordSearchSelection()">üßπ Limpiar Selecci√≥n</button>
                <button class="btn secondary" onclick="showMenu()">Men√∫ Principal</button>
            </div>
            
            <!-- Modal de felicitaciones para sopa de letras -->
            <div class="ws-overlay" id="ws-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
            <div class="ws-congratulations" id="ws-congratulations" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); text-align: center; z-index: 1000;">
                <h2>üéâ ¬°Felicitaciones! üéâ</h2>
                <p>¬°Has encontrado todas las palabras!</p>
                <button class="btn" onclick="closeWordSearchModal()">Continuar</button>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentScore = 0;
        let currentQuestion = 0;
        let algorithmStep = 0;
        let matchingPairs = 0;

        // Preguntas para la trivia
        const triviaQuestions = [
            {
                question: "¬øQu√© tipo de enrutamiento requiere configuraci√≥n manual de rutas?",
                options: ["Din√°mico", "Est√°tico", "Autom√°tico", "H√≠brido"],
                correct: 1
            },
            {
                question: "¬øCu√°l es la principal ventaja del enrutamiento din√°mico?",
                options: ["Menor uso de CPU", "Adaptaci√≥n autom√°tica a cambios", "Mayor seguridad", "Menos memoria"],
                correct: 1
            },
            {
                question: "¬øQu√© algoritmo usa el protocolo RIP para calcular rutas?",
                options: ["Dijkstra", "Vector Distancia", "Estado de Enlace", "Bellman-Ford"],
                correct: 1
            },
            {
                question: "¬øCu√°l es el l√≠mite m√°ximo de saltos en RIP?",
                options: ["10", "15", "20", "255"],
                correct: 1
            },
            {
                question: "¬øQu√© problema puede causar el 'count to infinity'?",
                options: ["Bucles de enrutamiento", "P√©rdida de paquetes", "Sobrecarga de red", "Todas las anteriores"],
                correct: 3
            },
            {
                question: "¬øCon qu√© frecuencia RIP env√≠a actualizaciones por defecto?",
                options: ["15 segundos", "30 segundos", "60 segundos", "90 segundos"],
                correct: 1
            },
            {
                question: "¬øQu√© protocolo usa el algoritmo de Dijkstra?",
                options: ["RIP", "OSPF", "BGP", "EIGRP"],
                correct: 1
            },
            {
                question: "¬øQu√© significa AS en el contexto de BGP?",
                options: ["Application Server", "Autonomous System", "Access Switch", "Administrative Station"],
                correct: 1
            }
        ];

        // Conceptos para matching
        const matchingConcepts = [
            { concept: "RIP", definition: "Protocolo que usa vector distancia" },
            { concept: "M√©trica", definition: "N√∫mero de saltos hasta el destino" },
            { concept: "Split Horizon", definition: "T√©cnica para evitar bucles" },
            { concept: "Hold Down", definition: "Temporizador de estabilizaci√≥n" },
            { concept: "Convergencia", definition: "Estado de tablas sincronizadas" },
            { concept: "Bellman-Ford", definition: "Algoritmo de vector distancia" }
        ];

        function startGame(gameType) {
            // Ocultar men√∫ principal
            document.getElementById('main-menu').classList.remove('active');
            
            switch(gameType) {
                case 'theory':
                    document.getElementById('theory-game').classList.add('active');
                    break;
                case 'trivia':
                    document.getElementById('trivia-game').classList.add('active');
                    startTrivia();
                    break;
                case 'algorithm':
                    document.getElementById('algorithm-game').classList.add('active');
                    initializeAlgorithm();
                    break;
                case 'matching':
                    document.getElementById('matching-game').classList.add('active');
                    initializeMatching();
                    break;
                case 'wordsearch':
                    document.getElementById('wordsearch-game').classList.add('active');
                    initializeWordSearch();
                    break;
            }
        }

        function showMenu() {
            // Ocultar todas las pantallas de juego
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            // Mostrar men√∫ principal
            document.getElementById('main-menu').classList.add('active');
            
            // Resetear variables
            currentScore = 0;
            currentQuestion = 0;
            algorithmStep = 0;
            matchingPairs = 0;
        }

        // Funciones de Trivia
        function startTrivia() {
            currentScore = 0;
            currentQuestion = 0;
            document.getElementById('score').textContent = currentScore;
            document.getElementById('total-questions').textContent = triviaQuestions.length;
            loadQuestion();
        }

        function loadQuestion() {
            if (currentQuestion >= triviaQuestions.length) {
                showTriviaResults();
                return;
            }

            const question = triviaQuestions[currentQuestion];
            const container = document.getElementById('question-container');
            
            container.innerHTML = `
                <div class="question">${question.question}</div>
                <div class="options">
                    ${question.options.map((option, index) => 
                        `<div class="option" onclick="selectAnswer(${index})">${option}</div>`
                    ).join('')}
                </div>
            `;
        }

        function selectAnswer(selectedIndex) {
            const question = triviaQuestions[currentQuestion];
            const options = document.querySelectorAll('.option');
            
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === selectedIndex) {
                    option.classList.add('incorrect');
                }
                option.onclick = null; // Deshabilitar clicks
            });

            if (selectedIndex === question.correct) {
                currentScore++;
                document.getElementById('score').textContent = currentScore;
            }
        }

        function nextQuestion() {
            currentQuestion++;
            loadQuestion();
        }

        function showTriviaResults() {
            const container = document.getElementById('question-container');
            const percentage = Math.round((currentScore / triviaQuestions.length) * 100);
            
            container.innerHTML = `
                <div class="question">¬°Juego Completado!</div>
                <div style="text-align: center; font-size: 1.5em; margin: 20px 0;">
                    Puntuaci√≥n Final: ${currentScore}/${triviaQuestions.length} (${percentage}%)
                </div>
                <div style="text-align: center;">
                    ${percentage >= 80 ? 'üéâ ¬°Excelente conocimiento!' : 
                      percentage >= 60 ? 'üëç ¬°Buen trabajo!' : 
                      'üìö Sigue estudiando'}
                </div>
            `;
        }

        // Funciones del Algoritmo Vector Distancia
        function initializeAlgorithm() {
            algorithmStep = 0;
            document.getElementById('algorithm-steps').innerHTML = '';
            document.getElementById('distance-tables').innerHTML = '';
            showAlgorithmIntro();
        }

        function showAlgorithmIntro() {
            document.getElementById('algorithm-steps').innerHTML = `
                <div class="algorithm-step">
                    <strong>Algoritmo de Vector Distancia - Inicializaci√≥n</strong><br>
                    Cada nodo conoce inicialmente solo las distancias a sus vecinos directos.
                    El algoritmo iterar√° hasta que todas las tablas converjan.
                </div>
            `;
            
            showInitialDistanceTables();
        }

        function showInitialDistanceTables() {
            const container = document.getElementById('distance-tables');
            container.innerHTML = '<h4>Iteraci√≥n 0 - Estado inicial</h4>';
            
            const nodes = ['A', 'B', 'C', 'D'];
            const topology = {
                A: { B: 2, D: 3 },
                B: { A: 2, C: 1 },
                C: { B: 1, D: 4 },
                D: { A: 3, C: 4 }
            };
            
            nodes.forEach(node => {
                const table = createDistanceTable(node, 0, topology);
                container.appendChild(table);
            });
        }

        function createDistanceTable(node, iteration, topology) {
            const div = document.createElement('div');
            div.style.cssText = 'display: inline-block; margin: 10px; background: #f8f9fa; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);';
            
            let tableHTML = `<h5 style="text-align: center; margin-bottom: 10px; color: #667eea;">Nodo ${node}</h5>
                            <table style="border-collapse: collapse; font-size: 0.9em;">
                            <tr><th style="border: 1px solid #ddd; padding: 8px; background: #667eea; color: white;">Dest</th>
                                <th style="border: 1px solid #ddd; padding: 8px; background: #667eea; color: white;">Dist</th></tr>`;
            
            const nodes = ['A', 'B', 'C', 'D'];
            nodes.forEach(dest => {
                let distance;
                if (dest === node) {
                    distance = 0;
                } else if (iteration === 0) {
                    distance = topology[node] && topology[node][dest] ? topology[node][dest] : '‚àû';
                } else {
                    distance = topology[node] && topology[node][dest] ? topology[node][dest] : '‚àû';
                }
                
                tableHTML += `<tr><td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${dest}</td>
                             <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${distance}</td></tr>`;
            });
              
            tableHTML += '</table>';
            div.innerHTML = tableHTML;
            return div;
        }

        function runAlgorithmStep() {
            algorithmStep++;
            
            const stepsContainer = document.getElementById('algorithm-steps');
            const newStep = document.createElement('div');
            newStep.className = 'algorithm-step';
            
            switch(algorithmStep) {
                case 1:
                    newStep.innerHTML = `<strong>Iteraci√≥n 1</strong><br>
                        Cada nodo intercambia su tabla de distancias con sus vecinos.
                        Se actualizan las rutas si se encuentra un camino m√°s corto.`;
                    break;
                case 2:
                    newStep.innerHTML = `<strong>Iteraci√≥n 2</strong><br>
                        Continuamos intercambiando informaci√≥n. El algoritmo converge cuando
                        no hay m√°s cambios en las tablas de enrutamiento.`;
                    break;
                case 3:
                    newStep.innerHTML = `<strong>Convergencia Alcanzada</strong><br>
                        Todas las tablas de enrutamiento est√°n estables. El algoritmo ha terminado.
                        ‚úÖ Red completamente configurada.`;
                    break;
                default:
                    newStep.innerHTML = `<strong>Algoritmo Completado</strong><br>
                        La red ha convergido. Todas las rutas √≥ptimas han sido calculadas.`;
            }
            
            stepsContainer.appendChild(newStep);
        }

        function resetAlgorithm() {
            initializeAlgorithm();
        }

        // Funciones del Juego de Matching
        function initializeMatching() {
            matchingPairs = 0;
            document.getElementById('matches').textContent = matchingPairs;
            document.getElementById('total-matches').textContent = matchingConcepts.length;
            createMatchingGame();
        }

        function createMatchingGame() {
            const container = document.getElementById('matching-area');
            container.innerHTML = '';
            
            // Crear dos columnas
            const leftColumn = document.createElement('div');
            const rightColumn = document.createElement('div');
            
            leftColumn.style.cssText = 'display: inline-block; width: 45%; vertical-align: top; margin: 2.5%;';
            rightColumn.style.cssText = 'display: inline-block; width: 45%; vertical-align: top; margin: 2.5%;';
            
            // Mezclar conceptos y definiciones
            const shuffledConcepts = [...matchingConcepts].sort(() => Math.random() - 0.5);
            const shuffledDefinitions = [...matchingConcepts].sort(() => Math.random() - 0.5);
            
            // Crear elementos de conceptos
            shuffledConcepts.forEach((item, index) => {
                const conceptElement = document.createElement('div');
                conceptElement.className = 'matching-item concept';
                conceptElement.textContent = item.concept;
                conceptElement.dataset.id = matchingConcepts.indexOf(item);
                conceptElement.onclick = () => selectMatchingItem(conceptElement);
                
                conceptElement.style.cssText = `
                    background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                    padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                `;
                
                leftColumn.appendChild(conceptElement);
            });
            
            // Crear elementos de definiciones
            shuffledDefinitions.forEach((item, index) => {
                const definitionElement = document.createElement('div');
                definitionElement.className = 'matching-item definition';
                definitionElement.textContent = item.definition;
                definitionElement.dataset.id = matchingConcepts.indexOf(item);
                definitionElement.onclick = () => selectMatchingItem(definitionElement);
                
                definitionElement.style.cssText = `
                    background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                    padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                `;
                
                rightColumn.appendChild(definitionElement);
            });
            
            container.appendChild(leftColumn);
            container.appendChild(rightColumn);
        }

        let selectedMatchingItems = [];

        function selectMatchingItem(element) {
            if (element.classList.contains('matched')) return;
            
            if (element.classList.contains('selected')) {
                element.classList.remove('selected');
                element.style.transform = 'scale(1)';
                selectedMatchingItems = selectedMatchingItems.filter(item => item !== element);
            } else {
                element.classList.add('selected');
                element.style.transform = 'scale(1.05)';
                selectedMatchingItems.push(element);
            }
            
            if (selectedMatchingItems.length === 2) {
                checkMatch();
            }
        }

        function checkMatch() {
            const [item1, item2] = selectedMatchingItems;
            
            if (item1.dataset.id === item2.dataset.id) {
                // Match correcto
                item1.classList.add('matched');
                item2.classList.add('matched');
                item1.style.cssText += 'background: #d4edda !important; border-color: #28a745 !important; transform: scale(1) !important;';
                item2.style.cssText += 'background: #d4edda !important; border-color: #28a745 !important; transform: scale(1) !important;';
                
                matchingPairs++;
                document.getElementById('matches').textContent = matchingPairs;
                
                if (matchingPairs === matchingConcepts.length) {
                    setTimeout(() => {
                        alert('¬°Felicidades! Has completado todos los emparejamientos correctamente. üéâ');
                    }, 500);
                }
            } else {
                // Match incorrecto
                item1.style.cssText += 'background: #f8d7da !important; border-color: #dc3545 !important;';
                item2.style.cssText += 'background: #f8d7da !important; border-color: #dc3545 !important;';
                
                setTimeout(() => {
                    item1.classList.remove('selected');
                    item2.classList.remove('selected');
                    item1.style.transform = 'scale(1)';
                    item2.style.transform = 'scale(1)';
                    
                    // Restaurar colores originales
                    if (item1.classList.contains('concept')) {
                        item1.style.cssText = `
                            background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    } else {
                        item1.style.cssText = `
                            background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    }
                    
                    if (item2.classList.contains('concept')) {
                        item2.style.cssText = `
                            background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    } else {
                        item2.style.cssText = `
                            background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    }
                }, 1000);
            }
            
            selectedMatchingItems = [];
        }

        function shuffleMatching() {
            initializeMatching();
        }

        // === FUNCIONES DE SOPA DE LETRAS ===
        const WS_GRID_SIZE = 15;
        const wsWords = [
            'RIP', 'OSPF', 'EIGRP', 'METRICA', 'CONVERGENCIA',
            'ENLACE', 'VECTOR', 'DISTANCIA', 'SALTO', 'TABLA'
        ];
        
        let wsGrid = [];
        let wsFoundWords = new Set();
        let wsIsSelecting = false;
        let wsSelectedCells = [];
        let wsStartCell = null;

        function initializeWordSearch() {
            wsGrid = Array(WS_GRID_SIZE).fill().map(() => Array(WS_GRID_SIZE).fill(''));
            wsFoundWords.clear();
            wsSelectedCells = [];
            wsIsSelecting = false;
            wsStartCell = null;
            
            // Colocar palabras en la cuadr√≠cula
            wsWords.forEach(word => placeWordInWS(word));
            
            // Llenar espacios vac√≠os con letras aleatorias
            fillEmptyWSSpaces();
            
            // Renderizar cuadr√≠cula
            renderWSGrid();
            renderWSWordsList();
            updateWSScore();
        }
        
        function placeWordInWS(word) {
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 100) {
                const direction = Math.floor(Math.random() * 8); // 8 direcciones posibles
                const startRow = Math.floor(Math.random() * WS_GRID_SIZE);
                const startCol = Math.floor(Math.random() * WS_GRID_SIZE);
                
                if (canPlaceWSWord(word, startRow, startCol, direction)) {
                    placeWSWordInGrid(word, startRow, startCol, direction);
                    placed = true;
                }
                attempts++;
            }
        }
        
        function canPlaceWSWord(word, startRow, startCol, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dRow, dCol] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = startRow + i * dRow;
                const newCol = startCol + i * dCol;
                
                if (newRow < 0 || newRow >= WS_GRID_SIZE || 
                    newCol < 0 || newCol >= WS_GRID_SIZE) {
                    return false;
                }
                
                if (wsGrid[newRow][newCol] !== '' && 
                    wsGrid[newRow][newCol] !== word[i]) {
                    return false;
                }
            }
            return true;
        }
        
        function placeWSWordInGrid(word, startRow, startCol, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dRow, dCol] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = startRow + i * dRow;
                const newCol = startCol + i * dCol;
                wsGrid[newRow][newCol] = word[i];
            }
        }
        
        function fillEmptyWSSpaces() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let row = 0; row < WS_GRID_SIZE; row++) {
                for (let col = 0; col < WS_GRID_SIZE; col++) {
                    if (wsGrid[row][col] === '') {
                        wsGrid[row][col] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }
        
        function renderWSGrid() {
            const gridElement = document.getElementById('ws-letterGrid');
            gridElement.innerHTML = '';
            
            for (let row = 0; row < WS_GRID_SIZE; row++) {
                for (let col = 0; col < WS_GRID_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'ws-cell';
                    cell.textContent = wsGrid[row][col];
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    cell.addEventListener('mousedown', startWSSelection);
                    cell.addEventListener('mouseenter', continueWSSelection);
                    cell.addEventListener('mouseup', endWSSelection);
                    
                    gridElement.appendChild(cell);
                }
            }
        }
        
        function renderWSWordsList() {
            const wordsListElement = document.getElementById('ws-wordsList');
            wordsListElement.innerHTML = '';
            
            wsWords.forEach(word => {
                const wordElement = document.createElement('div');
                wordElement.className = `ws-word-item ${wsFoundWords.has(word) ? 'found' : ''}`;
                wordElement.textContent = word;
                wordsListElement.appendChild(wordElement);
            });
        }
        
        function startWSSelection(e) {
            wsIsSelecting = true;
            wsSelectedCells = [];
            wsStartCell = {
                row: parseInt(e.target.dataset.row),
                col: parseInt(e.target.dataset.col)
            };
            
            clearWordSearchSelection();
            selectWSCell(e.target);
            e.preventDefault();
        }
        
        function continueWSSelection(e) {
            if (!wsIsSelecting) return;
            
            const currentRow = parseInt(e.target.dataset.row);
            const currentCol = parseInt(e.target.dataset.col);
            
            // Limpiar selecci√≥n anterior
            clearWSCellSelection();
            
            // Seleccionar l√≠nea recta desde wsStartCell hasta la celda actual
            const cells = getWSLineCells(wsStartCell.row, wsStartCell.col, currentRow, currentCol);
            cells.forEach(cell => {
                const element = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                if (element) selectWSCell(element);
            });
        }
        
        function endWSSelection(e) {
            if (!wsIsSelecting) return;
            wsIsSelecting = false;
            
            const selectedWord = wsSelectedCells.map(cell => cell.textContent).join('');
            const reverseWord = selectedWord.split('').reverse().join('');
            
            if (wsWords.includes(selectedWord) && !wsFoundWords.has(selectedWord)) {
                wsFoundWords.add(selectedWord);
                markWSCellsAsFound();
            } else if (wsWords.includes(reverseWord) && !wsFoundWords.has(reverseWord)) {
                wsFoundWords.add(reverseWord);
                markWSCellsAsFound();
            } else {
                clearWordSearchSelection();
            }
            
            renderWSWordsList();
            updateWSScore();
            
            if (wsFoundWords.size === wsWords.length) {
                setTimeout(showWSCongratulations, 500);
            }
        }
        
        function getWSLineCells(startRow, startCol, endRow, endCol) {
            const cells = [];
            const deltaRow = endRow - startRow;
            const deltaCol = endCol - startCol;
            
            // Solo permitir l√≠neas rectas (horizontal, vertical, diagonal)
            if (deltaRow !== 0 && deltaCol !== 0 && Math.abs(deltaRow) !== Math.abs(deltaCol)) {
                return [{row: startRow, col: startCol}];
            }
            
            const steps = Math.max(Math.abs(deltaRow), Math.abs(deltaCol));
            const stepRow = steps === 0 ? 0 : deltaRow / steps;
            const stepCol = steps === 0 ? 0 : deltaCol / steps;
            
            for (let i = 0; i <= steps; i++) {
                cells.push({
                    row: startRow + Math.round(i * stepRow),
                    col: startCol + Math.round(i * stepCol)
                });
            }
            
            return cells;
        }
        
        function selectWSCell(element) {
            element.classList.add('selected');
            wsSelectedCells.push(element);
        }
        
        function clearWSCellSelection() {
            wsSelectedCells.forEach(cell => cell.classList.remove('selected'));
            wsSelectedCells = [];
        }
        
        function clearWordSearchSelection() {
            document.querySelectorAll('.ws-cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            wsSelectedCells = [];
        }
        
        function markWSCellsAsFound() {
            wsSelectedCells.forEach(cell => {
                cell.classList.remove('selected');
                cell.classList.add('found');
            });
            wsSelectedCells = [];
        }
        
        function updateWSScore() {
            document.getElementById('ws-foundCount').textContent = wsFoundWords.size;
            document.getElementById('ws-totalCount').textContent = wsWords.length;
        }
        
        function showWSCongratulations() {
            document.getElementById('ws-overlay').style.display = 'block';
            document.getElementById('ws-congratulations').style.display = 'block';
        }
        
        function closeWordSearchModal() {
            document.getElementById('ws-overlay').style.display = 'none';
            document.getElementById('ws-congratulations').style.display = 'none';
        }
        
        function newWordSearchGame() {
            initializeWordSearch();
        }

        // Inicializaci√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üåê Juego de Enrutamiento de Redes cargado correctamente');
        });
    </script>
</body>
</html>
