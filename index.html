<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego de Enrutamiento de Redes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 900px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .game-option {
            background: linear-gradient(45deg, #ff6b6b, #ffa500);
            color: white;
            padding: 25px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .game-screen {
            display: none;
        }

        .game-screen.active {
            display: block;
        }

        /* Estilos para el simulador de red */
        .network-simulator {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .node {
            width: 60px;
            height: 60px;
            background: #4CAF50;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .node:hover {
            transform: scale(1.1);
            background: #45a049;
        }

        .node.selected {
            background: #ff5722;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.5);
        }

        .routing-table {
            background: white;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .routing-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .routing-table th,
        .routing-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .routing-table th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        /* Estilos para trivia */
        .question-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: left;
        }

        .question {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #333;
            font-weight: bold;
        }

        .options {
            display: grid;
            gap: 10px;
        }

        .option {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            border-color: #667eea;
            background: #f0f0ff;
        }

        .option.correct {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }

        .option.incorrect {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .score-board {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.2em;
            font-weight: bold;
        }

        .controls {
            margin: 20px 0;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn.secondary {
            background: linear-gradient(45deg, #6c757d, #495057);
        }

        .algorithm-step {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 10px 10px 0;
        }

        .network-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
            align-items: center;
            justify-items: center;
        }

        .connection {
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #666;
            padding: 5px 10px;
            background: #f0f0f0;
            border-radius: 15px;
            margin: 5px;
        }

        /* Estilos para Sopa de Letras */
        .wordsearch-grid-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }

        .wordsearch-grid {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            gap: 2px;
            margin-bottom: 20px;
        }

        .ws-cell {
            width: 25px;
            height: 25px;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            border-radius: 4px;
        }

        .ws-cell:hover {
            background: #e3f2fd;
            transform: scale(1.1);
        }

        .ws-cell.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .ws-cell.found {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .wordsearch-words-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            min-width: 200px;
            max-width: 250px;
        }

        .ws-word-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9em;
        }

        .ws-word-item.found {
            background: #4CAF50;
            color: white;
            border-left-color: #45a049;
            text-decoration: line-through;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>🌐 Juego de Enrutamiento de Redes</h1>
        
        <!-- Menú Principal -->
        <div id="main-menu" class="game-screen active">
            <p style="font-size: 1.2em; color: #666; margin-bottom: 30px;">
                Aprende sobre enrutamiento estático, dinámico y algoritmos de vector distancia
            </p>
            
            <div class="game-menu">
                <button class="game-option" onclick="startGame('trivia')">
                    🧠 Trivia de Enrutamiento
                </button>
                <button class="game-option" onclick="startGame('simulator')">
                    🔧 Simulador de Red
                </button>
                <button class="game-option" onclick="startGame('algorithm')">
                    📊 Vector Distancia
                </button>
                <button class="game-option" onclick="startGame('matching')">
                    🎯 Unir Conceptos
                </button>
                <button class="game-option" onclick="startGame('wordsearch')">
                    🔍 Sopa de Letras
                </button>
            </div>
        </div>

<!-- Teoria -->
<section id="theory" class="content-section">
    <h2>Teoría: Enrutamiento Estático y Dinámico</h2>
    <p>El enrutamiento es el proceso mediante el cual un router selecciona el mejor camino para enviar paquetes hacia su destino. 
    Existen dos enfoques principales: <b>enrutamiento estático</b> y <b>enrutamiento dinámico</b>.</p>

    <h3>Enrutamiento Estático</h3>
    <p>Es aquel en el que las rutas son configuradas manualmente por el administrador de red. 
    Se utilizan en redes pequeñas o con topologías muy estables.</p>
    <div class="info-card">
        <ul>
            <li><b>Ventajas:</b> Simplicidad, bajo consumo de recursos, mayor control del tráfico.</li>
            <li><b>Desventajas:</b> No se adapta a cambios automáticamente, difícil de administrar en redes grandes.</li>
        </ul>
    </div>

    <h3>Enrutamiento Dinámico</h3>
    <p>Utiliza protocolos de enrutamiento para que los routers intercambien información y ajusten automáticamente sus tablas de enrutamiento. 
    Ejemplos de protocolos son <b>RIP, OSPF, EIGRP y BGP</b>.</p>
    <div class="info-card">
        <ul>
            <li><b>Ventajas:</b> Adaptabilidad a cambios, escalabilidad en redes grandes.</li>
            <li><b>Desventajas:</b> Mayor consumo de CPU, memoria y ancho de banda; más complejo de configurar.</li>
        </ul>
    </div>

    <h3>Comparación</h3>
    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th>Característica</th>
                    <th>Estático</th>
                    <th>Dinámico</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Configuración</td>
                    <td>Manual</td>
                    <td>Automática (protocolos)</td>
                </tr>
                <tr>
                    <td>Escalabilidad</td>
                    <td>Baja</td>
                    <td>Alta</td>
                </tr>
                <tr>
                    <td>Adaptación a fallos</td>
                    <td>Nula</td>
                    <td>Automática</td>
                </tr>
                <tr>
                    <td>Uso de recursos</td>
                    <td>Bajo</td>
                    <td>Moderado/Alto</td>
                    
                </tr>
            </tbody>
        </table>
    </div>
</section>
</script>

        <!-- Trivia Game -->
        <div id="trivia-game" class="game-screen">
            <div class="score-board">
                Puntuación: <span id="score">0</span> / <span id="total-questions">0</span>
            </div>
            
            <div id="question-container" class="question-card">
                <!-- Las preguntas se cargarán aquí -->
            </div>
            
            <div class="controls">
                <button class="btn" onclick="nextQuestion()">Siguiente Pregunta</button>
                <button class="btn secondary" onclick="showMenu()">Menú Principal</button>
            </div>
        </div>

        <!-- Simulador de Red -->
        <div id="network-simulator" class="game-screen">
            <h2>Simulador de Red - Configuración de Rutas</h2>
            
            <div class="network-display">
                <div class="node" id="nodeA" onclick="selectNode('A')">A</div>
                <div class="connection">2</div>
                <div class="node" id="nodeB" onclick="selectNode('B')">B</div>
                <div class="connection">3</div>
                <div class="node" id="nodeC" onclick="selectNode('C')">C</div>
                <div class="connection">1</div>
                <div class="node" id="nodeD" onclick="selectNode('D')">D</div>
                <div class="connection">4</div>
                <div class="node" id="nodeE" onclick="selectNode('E')">E</div>
            </div>

            <div class="routing-table">
                <h3>Tabla de Enrutamiento - Nodo <span id="selected-node">A</span></h3>
                <table id="routing-table">
                    <thead>
                        <tr>
                            <th>Destino</th>
                            <th>Distancia</th>
                            <th>Siguiente Salto</th>
                            <th>Tipo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Se llenará dinámicamente -->
                    </tbody>
                </table>
            </div>

            <div class="controls">
                <button class="btn" onclick="calculateRoutes()">Calcular Rutas Dinámicas</button>
                <button class="btn" onclick="resetNetwork()">Reiniciar Red</button>
                <button class="btn secondary" onclick="showMenu()">Menú Principal</button>
            </div>
        </div>

        <!-- Algoritmo Vector Distancia -->
        <div id="algorithm-game" class="game-screen">
            <h2>Algoritmo de Vector Distancia (Bellman-Ford)</h2>
            
            <div id="algorithm-steps">
                <!-- Los pasos se mostrarán aquí -->
            </div>
            
            <div class="routing-table">
                <h3>Evolución de las Tablas de Enrutamiento</h3>
                <div id="distance-tables">
                    <!-- Tablas de distancia -->
                </div>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="runAlgorithmStep()">Siguiente Iteración</button>
                <button class="btn" onclick="resetAlgorithm()">Reiniciar Algoritmo</button>
                <button class="btn secondary" onclick="showMenu()">Menú Principal</button>
            </div>
        </div>

        <!-- Juego de Unir Conceptos -->
        <div id="matching-game" class="game-screen">
            <h2>Unir Conceptos de Enrutamiento</h2>
            
            <div id="matching-area">
                <!-- El juego de matching se cargará aquí -->
            </div>
            
            <div class="score-board">
                Aciertos: <span id="matches">0</span> / <span id="total-matches">6</span>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="shuffleMatching()">Nueva Ronda</button>
                <button class="btn secondary" onclick="showMenu()">Menú Principal</button>
            </div>
        </div>

        <!-- Sopa de Letras -->
        <div id="wordsearch-game" class="game-screen">
            <h2>🔍 Sopa de Letras - Términos de Enrutamiento</h2>
            
            <div class="score-board">
                Palabras encontradas: <span id="ws-foundCount">0</span> / <span id="ws-totalCount">10</span>
            </div>

            <div style="display: flex; gap: 30px; justify-content: center; align-items: flex-start; flex-wrap: wrap; margin: 20px 0;">
                <div class="wordsearch-grid-container">
                    <div class="wordsearch-grid" id="ws-letterGrid"></div>
                </div>

                <div class="wordsearch-words-panel">
                    <div style="font-size: 1.2em; font-weight: bold; margin-bottom: 15px; color: #333; text-align: center;">Palabras a encontrar:</div>
                    <div id="ws-wordsList"></div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="newWordSearchGame()">🎮 Nuevo Juego</button>
                <button class="btn" onclick="clearWordSearchSelection()">🧹 Limpiar Selección</button>
                <button class="btn secondary" onclick="showMenu()">Menú Principal</button>
            </div>
            
            <!-- Modal de felicitaciones para sopa de letras -->
            <div class="ws-overlay" id="ws-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>
            <div class="ws-congratulations" id="ws-congratulations" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.3); text-align: center; z-index: 1000;">
                <h2>🎉 ¡Felicitaciones! 🎉</h2>
                <p>¡Has encontrado todas las palabras!</p>
                <button class="btn" onclick="closeWordSearchModal()">Continuar</button>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentScore = 0;
        let currentQuestion = 0;
        let selectedNode = 'A';
        let algorithmStep = 0;
        let matchingPairs = 0;

        // Preguntas para la trivia
        const triviaQuestions = [
            {
                question: "¿Qué tipo de enrutamiento requiere configuración manual de rutas?",
                options: ["Dinámico", "Estático", "Automático", "Híbrido"],
                correct: 1
            },
            {
                question: "¿Cuál es la principal ventaja del enrutamiento dinámico?",
                options: ["Menor uso de CPU", "Adaptación automática a cambios", "Mayor seguridad", "Menos memoria"],
                correct: 1
            },
            {
                question: "¿Qué algoritmo usa el protocolo RIP para calcular rutas?",
                options: ["Dijkstra", "Vector Distancia", "Estado de Enlace", "Bellman-Ford"],
                correct: 1
            },
            {
                question: "¿Cuál es el límite máximo de saltos en RIP?",
                options: ["10", "15", "20", "255"],
                correct: 1
            },
            {
                question: "¿Qué problema puede causar el 'count to infinity'?",
                options: ["Bucles de enrutamiento", "Pérdida de paquetes", "Sobrecarga de red", "Todas las anteriores"],
                correct: 3
            },
            {
                question: "¿Con qué frecuencia RIP envía actualizaciones por defecto?",
                options: ["15 segundos", "30 segundos", "60 segundos", "90 segundos"],
                correct: 1
            }
        ];

        // Datos de la red
        const networkTopology = {
            A: { B: 2, D: 3 },
            B: { A: 2, C: 1, E: 4 },
            C: { B: 1, E: 2 },
            D: { A: 3, E: 1 },
            E: { B: 4, C: 2, D: 1 }
        };

        // Conceptos para matching
        const matchingConcepts = [
            { concept: "RIP", definition: "Protocolo que usa vector distancia" },
            { concept: "Métrica", definition: "Número de saltos hasta el destino" },
            { concept: "Split Horizon", definition: "Técnica para evitar bucles" },
            { concept: "Hold Down", definition: "Temporizador de estabilización" },
            { concept: "Convergencia", definition: "Estado de tablas sincronizadas" },
            { concept: "Bellman-Ford", definition: "Algoritmo de vector distancia" }
        ];

        function startGame(gameType) {
            // Ocultar menú principal
            document.getElementById('main-menu').classList.remove('active');
            
            switch(gameType) {
                case 'trivia':
                    document.getElementById('trivia-game').classList.add('active');
                    startTrivia();
                    break;
                case 'simulator':
                    document.getElementById('network-simulator').classList.add('active');
                    initializeNetworkSimulator();
                    break;
                case 'algorithm':
                    document.getElementById('algorithm-game').classList.add('active');
                    initializeAlgorithm();
                    break;
                case 'matching':
                    document.getElementById('matching-game').classList.add('active');
                    initializeMatching();
                    break;
                case 'wordsearch':
                    document.getElementById('wordsearch-game').classList.add('active');
                    initializeWordSearch();
                    break;
            }
        }

        function showMenu() {
            // Ocultar todas las pantallas de juego
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            // Mostrar menú principal
            document.getElementById('main-menu').classList.add('active');
            
            // Resetear variables
            currentScore = 0;
            currentQuestion = 0;
            algorithmStep = 0;
            matchingPairs = 0;
        }

        // Funciones de Trivia
        function startTrivia() {
            currentScore = 0;
            currentQuestion = 0;
            document.getElementById('score').textContent = currentScore;
            document.getElementById('total-questions').textContent = triviaQuestions.length;
            loadQuestion();
        }

        function loadQuestion() {
            if (currentQuestion >= triviaQuestions.length) {
                showTriviaResults();
                return;
            }

            const question = triviaQuestions[currentQuestion];
            const container = document.getElementById('question-container');
            
            container.innerHTML = `
                <div class="question">${question.question}</div>
                <div class="options">
                    ${question.options.map((option, index) => 
                        `<div class="option" onclick="selectAnswer(${index})">${option}</div>`
                    ).join('')}
                </div>
            `;
        }

        function selectAnswer(selectedIndex) {
            const question = triviaQuestions[currentQuestion];
            const options = document.querySelectorAll('.option');
            
            options.forEach((option, index) => {
                if (index === question.correct) {
                    option.classList.add('correct');
                } else if (index === selectedIndex) {
                    option.classList.add('incorrect');
                }
                option.onclick = null; // Deshabilitar clicks
            });

            if (selectedIndex === question.correct) {
                currentScore++;
                document.getElementById('score').textContent = currentScore;
            }
        }

        function nextQuestion() {
            currentQuestion++;
            loadQuestion();
        }

        function showTriviaResults() {
            const container = document.getElementById('question-container');
            const percentage = Math.round((currentScore / triviaQuestions.length) * 100);
            
            container.innerHTML = `
                <div class="question">¡Juego Completado!</div>
                <div style="text-align: center; font-size: 1.5em; margin: 20px 0;">
                    Puntuación Final: ${currentScore}/${triviaQuestions.length} (${percentage}%)
                </div>
                <div style="text-align: center;">
                    ${percentage >= 80 ? '🎉 ¡Excelente conocimiento!' : 
                      percentage >= 60 ? '👍 ¡Buen trabajo!' : 
                      '📚 Sigue estudiando'}
                </div>
            `;
        }

        // Funciones del Simulador de Red
        function initializeNetworkSimulator() {
            selectedNode = 'A';
            updateNodeSelection();
            updateRoutingTable();
        }

        function selectNode(node) {
            selectedNode = node;
            updateNodeSelection();
            updateRoutingTable();
        }

        function updateNodeSelection() {
            // Limpiar selecciones previas
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected');
            });
            
            // Seleccionar nodo actual
            document.getElementById('node' + selectedNode).classList.add('selected');
            document.getElementById('selected-node').textContent = selectedNode;
        }

        function updateRoutingTable() {
            const table = document.getElementById('routing-table').getElementsByTagName('tbody')[0];
            table.innerHTML = '';

            // Obtener rutas para el nodo seleccionado
            const routes = calculateShortestPaths(selectedNode);
            
            Object.keys(routes).forEach(dest => {
                if (dest !== selectedNode) {
                    const row = table.insertRow();
                    row.insertCell(0).textContent = dest;
                    row.insertCell(1).textContent = routes[dest].distance === Infinity ? '∞' : routes[dest].distance;
                    row.insertCell(2).textContent = routes[dest].nextHop || '-';
                    row.insertCell(3).textContent = routes[dest].distance === Infinity ? 'Inalcanzable' : 'Dinámico';
                }
            });
        }

        function calculateShortestPaths(source) {
            const distances = {};
            const nextHop = {};
            const visited = {};

            // Inicializar distancias
            Object.keys(networkTopology).forEach(node => {
                distances[node] = node === source ? 0 : Infinity;
                nextHop[node] = null;
                visited[node] = false;
            });

            // Algoritmo de Dijkstra simplificado
            for (let i = 0; i < Object.keys(networkTopology).length; i++) {
                let minNode = null;
                let minDistance = Infinity;

                // Encontrar el nodo no visitado con menor distancia
                Object.keys(distances).forEach(node => {
                    if (!visited[node] && distances[node] < minDistance) {
                        minDistance = distances[node];
                        minNode = node;
                    }
                });

                if (minNode === null) break;
                visited[minNode] = true;

                // Actualizar distancias a vecinos
                if (networkTopology[minNode]) {
                    Object.keys(networkTopology[minNode]).forEach(neighbor => {
                        const newDistance = distances[minNode] + networkTopology[minNode][neighbor];
                        if (newDistance < distances[neighbor]) {
                            distances[neighbor] = newDistance;
                            nextHop[neighbor] = minNode === source ? neighbor : nextHop[minNode];
                        }
                    });
                }
            }

            // Formatear resultado
            const result = {};
            Object.keys(distances).forEach(node => {
                result[node] = {
                    distance: distances[node],
                    nextHop: nextHop[node]
                };
            });

            return result;
        }

        function calculateRoutes() {
            updateRoutingTable();
            
            // Mostrar mensaje de actualización
            const steps = document.createElement('div');
            steps.className = 'algorithm-step';
            steps.innerHTML = `<strong>Rutas calculadas para el nodo ${selectedNode}</strong><br>
                              Se ha ejecutado el algoritmo de vector distancia para encontrar las rutas más cortas.`;
            
            // Insertar al principio del contenedor
            const container = document.getElementById('network-simulator');
            container.insertBefore(steps, container.querySelector('.controls'));
            
            // Remover el mensaje después de 3 segundos
            setTimeout(() => steps.remove(), 3000);
        }

        function resetNetwork() {
            selectedNode = 'A';
            updateNodeSelection();
            updateRoutingTable();
            
            // Limpiar mensajes de algoritmo
            document.querySelectorAll('.algorithm-step').forEach(step => step.remove());
        }

        // Funciones del Algoritmo Vector Distancia
        function initializeAlgorithm() {
            algorithmStep = 0;
            document.getElementById('algorithm-steps').innerHTML = '';
            document.getElementById('distance-tables').innerHTML = '';
            showAlgorithmIntro();
        }

        function showAlgorithmIntro() {
            document.getElementById('algorithm-steps').innerHTML = `
                <div class="algorithm-step">
                    <strong>Algoritmo de Vector Distancia - Inicialización</strong><br>
                    Cada nodo conoce inicialmente solo las distancias a sus vecinos directos.
                    El algoritmo iterará hasta que todas las tablas converjan.
                </div>
            `;
            
            showInitialDistanceTables();
        }

        function showInitialDistanceTables() {
            const container = document.getElementById('distance-tables');
            container.innerHTML = '<h4>Iteración 0 - Estado inicial</h4>';
            
            Object.keys(networkTopology).forEach(node => {
                const table = createDistanceTable(node, 0);
                container.appendChild(table);
            });
        }

        function createDistanceTable(node, iteration) {
            const div = document.createElement('div');
            div.style.display = 'inline-block';
            div.style.margin = '10px';
            div.style.background = '#f8f9fa';
            div.style.padding = '10px';
            div.style.borderRadius = '8px';
            
            let tableHTML = `<h5>Nodo ${node}</h5><table style="border-collapse: collapse; font-size: 0.9em;">
                            <tr><th style="border: 1px solid #ddd; padding: 5px;">Dest</th><th style="border: 1px solid #ddd; padding: 5px;">Dist</th></tr>`;
            
            Object.keys(networkTopology).forEach(dest => {
                let distance;
                if (dest === node) {
                    distance = 0;
                } else if (iteration === 0) {
                    distance = networkTopology[node][dest] || '∞';
                } else {
                    // Aquí se calcularía la distancia en iteraciones posteriores
                    distance = networkTopology[node][dest] || '∞';
                }
                
                tableHTML += `<tr><td style="border: 1px solid #ddd; padding: 5px;">${dest}</td><td style="border: 1px solid #ddd; padding: 5px;">${distance}</td></tr>`;
            });
            
            tableHTML += '</table>';
            div.innerHTML = tableHTML;
            return div;
        }

        function runAlgorithmStep() {
            algorithmStep++;
            
            const stepsContainer = document.getElementById('algorithm-steps');
            const newStep = document.createElement('div');
            newStep.className = 'algorithm-step';
            
            switch(algorithmStep) {
                case 1:
                    newStep.innerHTML = `<strong>Iteración 1</strong><br>
                        Cada nodo intercambia su tabla de distancias con sus vecinos.
                        Se actualizan las rutas si se encuentra un camino más corto.`;
                    break;
                case 2:
                    newStep.innerHTML = `<strong>Iteración 2</strong><br>
                        Continuamos intercambiando información. El algoritmo converge cuando
                        no hay más cambios en las tablas de enrutamiento.`;
                    break;
                case 3:
                    newStep.innerHTML = `<strong>Convergencia Alcanzada</strong><br>
                        Todas las tablas de enrutamiento están estables. El algoritmo ha terminado.
                        ✅ Red completamente configurada.`;
                    break;
                default:
                    newStep.innerHTML = `<strong>Algoritmo Completado</strong><br>
                        La red ha convergido. Todas las rutas óptimas han sido calculadas.`;
            }
            
            stepsContainer.appendChild(newStep);
        }

        function resetAlgorithm() {
            initializeAlgorithm();
        }

        // Funciones del Juego de Matching
        function initializeMatching() {
            matchingPairs = 0;
            document.getElementById('matches').textContent = matchingPairs;
            document.getElementById('total-matches').textContent = matchingConcepts.length;
            createMatchingGame();
        }

        function createMatchingGame() {
            const container = document.getElementById('matching-area');
            container.innerHTML = '';
            
            // Crear dos columnas
            const leftColumn = document.createElement('div');
            const rightColumn = document.createElement('div');
            
            leftColumn.style.cssText = 'display: inline-block; width: 45%; vertical-align: top; margin: 2.5%;';
            rightColumn.style.cssText = 'display: inline-block; width: 45%; vertical-align: top; margin: 2.5%;';
            
            // Mezclar conceptos y definiciones
            const shuffledConcepts = [...matchingConcepts].sort(() => Math.random() - 0.5);
            const shuffledDefinitions = [...matchingConcepts].sort(() => Math.random() - 0.5);
            
            // Crear elementos de conceptos
            shuffledConcepts.forEach((item, index) => {
                const conceptElement = document.createElement('div');
                conceptElement.className = 'matching-item concept';
                conceptElement.textContent = item.concept;
                conceptElement.dataset.id = matchingConcepts.indexOf(item);
                conceptElement.onclick = () => selectMatchingItem(conceptElement);
                
                conceptElement.style.cssText = `
                    background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                    padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                `;
                
                leftColumn.appendChild(conceptElement);
            });
            
            // Crear elementos de definiciones
            shuffledDefinitions.forEach((item, index) => {
                const definitionElement = document.createElement('div');
                definitionElement.className = 'matching-item definition';
                definitionElement.textContent = item.definition;
                definitionElement.dataset.id = matchingConcepts.indexOf(item);
                definitionElement.onclick = () => selectMatchingItem(definitionElement);
                
                definitionElement.style.cssText = `
                    background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                    padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                `;
                
                rightColumn.appendChild(definitionElement);
            });
            
            container.appendChild(leftColumn);
            container.appendChild(rightColumn);
        }

        let selectedMatchingItems = [];

        function selectMatchingItem(element) {
            if (element.classList.contains('matched')) return;
            
            if (element.classList.contains('selected')) {
                element.classList.remove('selected');
                element.style.transform = 'scale(1)';
                selectedMatchingItems = selectedMatchingItems.filter(item => item !== element);
            } else {
                element.classList.add('selected');
                element.style.transform = 'scale(1.05)';
                selectedMatchingItems.push(element);
            }
            
            if (selectedMatchingItems.length === 2) {
                checkMatch();
            }
        }

        function checkMatch() {
            const [item1, item2] = selectedMatchingItems;
            
            if (item1.dataset.id === item2.dataset.id) {
                // Match correcto
                item1.classList.add('matched');
                item2.classList.add('matched');
                item1.style.cssText += 'background: #d4edda !important; border-color: #28a745 !important; transform: scale(1) !important;';
                item2.style.cssText += 'background: #d4edda !important; border-color: #28a745 !important; transform: scale(1) !important;';
                
                matchingPairs++;
                document.getElementById('matches').textContent = matchingPairs;
                
                if (matchingPairs === matchingConcepts.length) {
                    setTimeout(() => {
                        alert('¡Felicidades! Has completado todos los emparejamientos correctamente. 🎉');
                    }, 500);
                }
            } else {
                // Match incorrecto
                item1.style.cssText += 'background: #f8d7da !important; border-color: #dc3545 !important;';
                item2.style.cssText += 'background: #f8d7da !important; border-color: #dc3545 !important;';
                
                setTimeout(() => {
                    item1.classList.remove('selected');
                    item2.classList.remove('selected');
                    item1.style.transform = 'scale(1)';
                    item2.style.transform = 'scale(1)';
                    
                    // Restaurar colores originales
                    if (item1.classList.contains('concept')) {
                        item1.style.cssText = `
                            background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    } else {
                        item1.style.cssText = `
                            background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    }
                    
                    if (item2.classList.contains('concept')) {
                        item2.style.cssText = `
                            background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    } else {
                        item2.style.cssText = `
                            background: #fff3e0; border: 2px solid #ff9800; border-radius: 10px;
                            padding: 15px; margin: 10px 0; cursor: pointer; transition: all 0.3s ease;
                        `;
                    }
                }, 1000);
            }
            
            selectedMatchingItems = [];
        }

        function shuffleMatching() {
            initializeMatching();
        }

        // === FUNCIONES DE SOPA DE LETRAS ===
        const WS_GRID_SIZE = 15;
        const wsWords = [
            'RIP', 'OSPF', 'EIGRP', 'METRICA', 'CONVERGENCIA',
            'ENLACE', 'VECTOR', 'DISTANCIA', 'SALTO', 'TABLA'
        ];
        
        let wsGrid = [];
        let wsFoundWords = new Set();
        let wsIsSelecting = false;
        let wsSelectedCells = [];
        let wsStartCell = null;

        function initializeWordSearch() {
            wsGrid = Array(WS_GRID_SIZE).fill().map(() => Array(WS_GRID_SIZE).fill(''));
            wsFoundWords.clear();
            wsSelectedCells = [];
            wsIsSelecting = false;
            wsStartCell = null;
            
            // Colocar palabras en la cuadrícula
            wsWords.forEach(word => placeWordInWS(word));
            
            // Llenar espacios vacíos con letras aleatorias
            fillEmptyWSSpaces();
            
            // Renderizar cuadrícula
            renderWSGrid();
            renderWSWordsList();
            updateWSScore();
        }
        
        function placeWordInWS(word) {
            let placed = false;
            let attempts = 0;
            
            while (!placed && attempts < 100) {
                const direction = Math.floor(Math.random() * 8); // 8 direcciones posibles
                const startRow = Math.floor(Math.random() * WS_GRID_SIZE);
                const startCol = Math.floor(Math.random() * WS_GRID_SIZE);
                
                if (canPlaceWSWord(word, startRow, startCol, direction)) {
                    placeWSWordInGrid(word, startRow, startCol, direction);
                    placed = true;
                }
                attempts++;
            }
        }
        
        function canPlaceWSWord(word, startRow, startCol, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dRow, dCol] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = startRow + i * dRow;
                const newCol = startCol + i * dCol;
                
                if (newRow < 0 || newRow >= WS_GRID_SIZE || 
                    newCol < 0 || newCol >= WS_GRID_SIZE) {
                    return false;
                }
                
                if (wsGrid[newRow][newCol] !== '' && 
                    wsGrid[newRow][newCol] !== word[i]) {
                    return false;
                }
            }
            return true;
        }
        
        function placeWSWordInGrid(word, startRow, startCol, direction) {
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            const [dRow, dCol] = directions[direction];
            
            for (let i = 0; i < word.length; i++) {
                const newRow = startRow + i * dRow;
                const newCol = startCol + i * dCol;
                wsGrid[newRow][newCol] = word[i];
            }
        }
        
        function fillEmptyWSSpaces() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let row = 0; row < WS_GRID_SIZE; row++) {
                for (let col = 0; col < WS_GRID_SIZE; col++) {
                    if (wsGrid[row][col] === '') {
                        wsGrid[row][col] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }
        
        function renderWSGrid() {
            const gridElement = document.getElementById('ws-letterGrid');
            gridElement.innerHTML = '';
            
            for (let row = 0; row < WS_GRID_SIZE; row++) {
                for (let col = 0; col < WS_GRID_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'ws-cell';
                    cell.textContent = wsGrid[row][col];
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    cell.addEventListener('mousedown', startWSSelection);
                    cell.addEventListener('mouseenter', continueWSSelection);
                    cell.addEventListener('mouseup', endWSSelection);
                    
                    gridElement.appendChild(cell);
                }
            }
        }
        
        function renderWSWordsList() {
            const wordsListElement = document.getElementById('ws-wordsList');
            wordsListElement.innerHTML = '';
            
            wsWords.forEach(word => {
                const wordElement = document.createElement('div');
                wordElement.className = `ws-word-item ${wsFoundWords.has(word) ? 'found' : ''}`;
                wordElement.textContent = word;
                wordsListElement.appendChild(wordElement);
            });
        }
        
        function startWSSelection(e) {
            wsIsSelecting = true;
            wsSelectedCells = [];
            wsStartCell = {
                row: parseInt(e.target.dataset.row),
                col: parseInt(e.target.dataset.col)
            };
            
            clearWordSearchSelection();
            selectWSCell(e.target);
            e.preventDefault();
        }
        
        function continueWSSelection(e) {
            if (!wsIsSelecting) return;
            
            const currentRow = parseInt(e.target.dataset.row);
            const currentCol = parseInt(e.target.dataset.col);
            
            // Limpiar selección anterior
            clearWSCellSelection();
            
            // Seleccionar línea recta desde wsStartCell hasta la celda actual
            const cells = getWSLineCells(wsStartCell.row, wsStartCell.col, currentRow, currentCol);
            cells.forEach(cell => {
                const element = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
                if (element) selectWSCell(element);
            });
        }
        
        function endWSSelection(e) {
            if (!wsIsSelecting) return;
            wsIsSelecting = false;
            
            const selectedWord = wsSelectedCells.map(cell => cell.textContent).join('');
            const reverseWord = selectedWord.split('').reverse().join('');
            
            if (wsWords.includes(selectedWord) && !wsFoundWords.has(selectedWord)) {
                wsFoundWords.add(selectedWord);
                markWSCellsAsFound();
            } else if (wsWords.includes(reverseWord) && !wsFoundWords.has(reverseWord)) {
                wsFoundWords.add(reverseWord);
                markWSCellsAsFound();
            } else {
                clearWordSearchSelection();
            }
            
            renderWSWordsList();
            updateWSScore();
            
            if (wsFoundWords.size === wsWords.length) {
                setTimeout(showWSCongratulations, 500);
            }
        }
        
        function getWSLineCells(startRow, startCol, endRow, endCol) {
            const cells = [];
            const deltaRow = endRow - startRow;
            const deltaCol = endCol - startCol;
            
            // Solo permitir líneas rectas (horizontal, vertical, diagonal)
            if (deltaRow !== 0 && deltaCol !== 0 && Math.abs(deltaRow) !== Math.abs(deltaCol)) {
                return [{row: startRow, col: startCol}];
            }
            
            const steps = Math.max(Math.abs(deltaRow), Math.abs(deltaCol));
            const stepRow = steps === 0 ? 0 : deltaRow / steps;
            const stepCol = steps === 0 ? 0 : deltaCol / steps;
            
            for (let i = 0; i <= steps; i++) {
                cells.push({
                    row: startRow + Math.round(i * stepRow),
                    col: startCol + Math.round(i * stepCol)
                });
            }
            
            return cells;
        }
        
        function selectWSCell(element) {
            element.classList.add('selected');
            wsSelectedCells.push(element);
        }
        
        function clearWSCellSelection() {
            wsSelectedCells.forEach(cell => cell.classList.remove('selected'));
            wsSelectedCells = [];
        }
        
        function clearWordSearchSelection() {
            document.querySelectorAll('.ws-cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            wsSelectedCells = [];
        }
        
        function markWSCellsAsFound() {
            wsSelectedCells.forEach(cell => {
                cell.classList.remove('selected');
                cell.classList.add('found');
            });
            wsSelectedCells = [];
        }
        
        function updateWSScore() {
            document.getElementById('ws-foundCount').textContent = wsFoundWords.size;
            document.getElementById('ws-totalCount').textContent = wsWords.length;
        }
        
        function showWSCongratulations() {
            document.getElementById('ws-overlay').style.display = 'block';
            document.getElementById('ws-congratulations').style.display = 'block';
        }
        
        function closeWordSearchModal() {
            document.getElementById('ws-overlay').style.display = 'none';
            document.getElementById('ws-congratulations').style.display = 'none';
        }
        
        function newWordSearchGame() {
            initializeWordSearch();
        }

        // Inicialización cuando se carga la página
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🌐 Juego de Enrutamiento de Redes cargado correctamente');
        });
    </script>
</body>
</html>
